<!DOCTYPE html><head>     <meta charset="utf-8">    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">     <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>    <link type="text/css" rel="stylesheet" href="css/stylesheet.css"/>        <title> Treemap </title></head><body>    <div>      <ul id="navbar">        <li id="navlinkspace"> HW4 Coffee Visualization </li>        <li id="navlinkspace"> <a id="navlink" href="../HW4/exam3_1.html">Exam Problem 3.1</a> </li>        <li id="navlinkspace"> <a id="navlink" href="../HW4/exam3_2.html">Exam Problem 3.2</a> </li>        <li id="navlinkspace"> <a id="navlink" href="../HW4/exam3_3.html">Exam Problem 3.3</a> </li>    </ul>    </div>    <div id="header">            <h2> Coffee Profit on December 1st 2011 </h2>    </div>         <div id="body"> </div></body><script type="text/javascript">    var check = 1;    var width = 550;    var height = 550;    var xScale = d3.scale.linear().range([0, width]);    var yScale = d3.scale.linear().range([0, height]);    var color = d3.scale.category10();    var headerHeight = 20;    var headerColor = "#555555";    var transitionDuration = 500;    var root;    var node;    var csvLink = "https://hivelab.org/static/coffee.csv";    var coffeeTree;      var treemap = d3.layout.treemap()        .size([width, height])        .sticky(true)        .value(function(d) { return d.size; });    var chart = d3.select("#body")        .append("svg:svg")        .attr("width", width)        .attr("height", height)        .append("svg:g");    d3.csv(csvLink, function(data) {        coffeeTree = d3.nest()            .key(function(d) { if (d.date === "12/1/2011" ) { return "12/1/2011"; } })             .key(function(d) {return d.state; })                                .entries(data);        // console.log(coffeeTree[1]);        var temp = coffeeTree[1];        var root = reSortRoot(temp, "profit", "type");        var nodes = treemap.nodes(root);        node = root;        console.log(root);        var children = nodes.filter(function(d) { return !d.children; });        var parents = nodes.filter(function(d) { return d.children; });        // console.log(children);        // console.log(parents);        // Parent cells        var parentCells = chart.selectAll("g.cell.parent")            .data(parents, function(d) { return d.name; });                 var parentEnterTransition = parentCells.enter()            .append("g")            .attr("class", "cell parent")            .on("click", function(d) {                 check = 0;                 zoom(d);             });                        parentEnterTransition.append("rect")            .attr("width", function(d) { return Math.max(0.01, d.dx); })            .attr("height", headerHeight)            .style("fill", headerColor);                       parentEnterTransition.append("foreignObject").attr("class", "foreignObject")            .append("xhtml:body").attr("class", "labelbody")            .append("div").attr("class", "label");        // Children cells        var childrenCells = chart.selectAll("g.cell.child")            .data(children, function(d) { return d.state + d.name; });             console.log(childrenCells);                // Enter transition        var childEnterTransition = childrenCells.enter()            .append("g")            .attr("class", "cell child")            .on("click", function(d) {                          check = 0;                 zoom(node === d.parent ? root : d.parent);             });        childEnterTransition.append("rect")            .classed("background", true)            .style("fill", function(d) { return color(d.parent.name); });        childEnterTransition.append('foreignObject')            .attr("class", "foreignObject")            .attr("width", function(d) { return Math.max(0.01, d.dx); })            .attr("height", function(d) { return Math.max(0.01, d.dy); })            .append("xhtml:body")            .attr("class", "labelbody")            .append("div")            .attr("class", "label")               .text(function(d) { return d.name; });         if (check) {            check = 0;            childEnterTransition.selectAll(".foreignObject").style("display", "none");        } else {            check = 1;            childEnterTransition.selectAll(".foreignObject .labelbody .label").style("display", "none");        }        d3.select("select").on("change", function() {        //d3.select("#section").on("change", function() {                treemap.value(this.value == "size" ? function(d) { return d.size; } : function() { return 1; } )                   .nodes(root);                        zoom(node);        });        zoom(node);    });  function reSortRoot(root, value_key, value_name) {    for (var key in root) {      if (key == "key") {        root.name = root.key;        delete root.key;      }      if (key == "values") {        root.children = [];        for (item in root.values) {            root.children.push(reSortRoot(root.values[item], value_key, value_name ));        }        delete root.values;      }      if (key == value_key) {        root.size = parseFloat(root[value_key]);        root.name = root[value_name];        delete root[value_key];        delete root[value_name];      }    }    return root;  }    function zoom(d) {                this.treemap            .padding([headerHeight/(height/d.dy), 0, 0, 0])            .nodes(d);        var kx = width  / d.dx;        var ky = height / d.dy;        var level = d;        xScale.domain([d.x, d.x + d.dx]);        yScale.domain([d.y, d.y + d.dy]);        if (node != level) {            if (!check) {                check = 1;                chart.selectAll(".cell.child .foreignObject")                    .style("display", "none");            } else {                check = 0;                chart.selectAll(".cell.child .foreignObject .labelbody .label")                    .style("display", "none");            }        }        var zoomTransition = chart.selectAll("g.cell").transition().duration(transitionDuration)            .attr("transform", function(d) { return "translate(" + xScale(d.x) + "," + yScale(d.y) + ")"; })            .each("end", function(d, i) {                if (!i && (level !== self.root)) {                    chart.selectAll(".cell.child")                        .filter(function(d) { return d.parent === self.node; })                         .select(".foreignObject .labelbody .label")                        .style("color", "white");                     if (check) {                        chart.selectAll(".cell.child")                            .filter(function(d) { return d.parent === self.node; })                            .select(".foreignObject")                            .style("display", "");                        check = 0;                    } else {                        chart.selectAll(".cell.child")                            .filter(function(d) { return d.parent === self.node; })                            .select(".foreignObject .labelbody .label")                            .style("display", "");                        check = 1;                     }                }            });        zoomTransition.select(".foreignObject")            .attr("width", function(d) { return Math.max(0.01, kx * d.dx); })            .attr("height", function(d) { return d.children ? headerHeight: Math.max(0.01, ky * d.dy); })            .select(".labelbody .label")            .text(function(d) { return d.name; });        zoomTransition.select("rect")            .attr("width", function(d) { return Math.max(0.01, kx * d.dx); })            .attr("height", function(d) { return d.children ? headerHeight : Math.max(0.01, ky * d.dy); })            .style("fill", function(d) { return d.children ? headerColor : color(d.parent.name); });        node = d;    }</script></html>